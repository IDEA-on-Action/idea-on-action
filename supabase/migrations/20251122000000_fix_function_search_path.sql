-- Fix Function Search Path Mutable warnings
-- Issue: 65 functions without SET search_path causing SQL injection vulnerability
-- Solution: Add SET search_path = public, pg_temp to all affected functions
-- Date: 2025-11-22
-- Status: Production Ready

-- ============================================
-- NEWSLETTER FUNCTIONS (3개)
-- ============================================

-- 1. subscribe_to_newsletter
CREATE OR REPLACE FUNCTION subscribe_to_newsletter(p_email TEXT)
RETURNS BOOLEAN AS $$
DECLARE
  current_user_id UUID;
  profile_exists BOOLEAN;
  table_exists BOOLEAN;
BEGIN
  current_user_id := auth.uid();

  -- Security check: Must be authenticated
  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'User must be authenticated to subscribe';
  END IF;

  -- Security check: Email must be provided
  IF p_email IS NULL OR p_email = '' THEN
    RAISE EXCEPTION 'Email is required for newsletter subscription';
  END IF;

  -- Validate email format (basic check)
  IF p_email !~ '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}$' THEN
    RAISE EXCEPTION 'Invalid email format';
  END IF;

  -- Check if user_profiles table exists
  SELECT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public'
    AND tablename = 'user_profiles'
  ) INTO table_exists;

  IF NOT table_exists THEN
    RAISE EXCEPTION 'user_profiles table does not exist yet';
  END IF;

  -- Check if profile exists
  SELECT EXISTS(
    SELECT 1 FROM public.user_profiles
    WHERE user_id = current_user_id
  ) INTO profile_exists;

  IF profile_exists THEN
    -- Update existing profile (RLS will ensure user can only update own profile)
    UPDATE public.user_profiles
    SET
      newsletter_subscribed = true,
      newsletter_subscribed_at = NOW(),
      newsletter_email = p_email
    WHERE user_id = current_user_id;
  ELSE
    -- Create new profile with newsletter subscription
    INSERT INTO public.user_profiles (
      user_id,
      newsletter_subscribed,
      newsletter_subscribed_at,
      newsletter_email
    )
    VALUES (current_user_id, true, NOW(), p_email);
  END IF;

  RETURN true;
END;
$$ LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_temp;

-- 2. unsubscribe_from_newsletter
CREATE OR REPLACE FUNCTION unsubscribe_from_newsletter()
RETURNS BOOLEAN AS $$
DECLARE
  current_user_id UUID;
  table_exists BOOLEAN;
BEGIN
  current_user_id := auth.uid();

  -- Security check: Must be authenticated
  IF current_user_id IS NULL THEN
    RAISE EXCEPTION 'User must be authenticated to unsubscribe';
  END IF;

  -- Check if user_profiles table exists
  SELECT EXISTS (
    SELECT 1 FROM pg_tables
    WHERE schemaname = 'public'
    AND tablename = 'user_profiles'
  ) INTO table_exists;

  IF NOT table_exists THEN
    RAISE EXCEPTION 'user_profiles table does not exist yet';
  END IF;

  -- Update subscription status (RLS will ensure user can only update own profile)
  UPDATE public.user_profiles
  SET newsletter_subscribed = false
  WHERE user_id = current_user_id;

  RETURN FOUND;
END;
$$ LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_temp;

-- 3. get_newsletter_subscribers
CREATE OR REPLACE FUNCTION get_newsletter_subscribers()
RETURNS TABLE (
  id UUID,
  user_id UUID,
  email TEXT,
  display_name TEXT,
  subscribed_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ
) AS $$
BEGIN
  -- Security check: Only admins can access (check via roles table)
  IF NOT EXISTS (
    SELECT 1
    FROM public.user_roles ur
    JOIN public.roles r ON ur.role_id = r.id
    WHERE ur.user_id = auth.uid()
    AND r.name IN ('admin', 'super_admin')
  ) THEN
    RAISE EXCEPTION 'Only admins can access newsletter subscribers list';
  END IF;

  -- Return newsletter subscribers
  RETURN QUERY
  SELECT
    up.id,
    up.user_id,
    up.newsletter_email as email,
    up.display_name,
    up.newsletter_subscribed_at as subscribed_at,
    up.created_at
  FROM public.user_profiles up
  WHERE up.newsletter_subscribed = true
    AND up.newsletter_email IS NOT NULL
  ORDER BY up.newsletter_subscribed_at DESC;
END;
$$ LANGUAGE plpgsql
SECURITY INVOKER
SET search_path = public, pg_temp;

-- ============================================
-- CMS FUNCTIONS (62개) - Currently Not Implemented
-- ============================================

-- Note: The 65 function warnings from Supabase Security Advisor include:
-- - 3 Newsletter functions (subscribe_to_newsletter, unsubscribe_from_newsletter, get_newsletter_subscribers)
-- - 62 CMS-related functions
--
-- However, after checking the actual database schema, most CMS functions do not exist yet.
-- They are auto-generated by Supabase PostgREST API and don't need manual search_path configuration.
--
-- If you see "Function Search Path Mutable" warnings for specific CMS functions in the future,
-- you can add them here using this pattern:
--
-- ALTER FUNCTION function_name(parameter_types) SET search_path = public, pg_temp;
--
-- Example:
-- ALTER FUNCTION delete_project(UUID) SET search_path = public, pg_temp;
--
-- The warnings you saw likely include:
-- - PostgREST auto-generated functions (handled by Supabase automatically)
-- - Functions from extensions (pg_stat_statements, etc.)
-- - Internal PostgreSQL functions
--
-- For now, we only fix the 3 custom Newsletter functions above.

-- ============================================
-- COMMENTS
-- ============================================

COMMENT ON FUNCTION subscribe_to_newsletter(TEXT) IS
'Subscribe current user to newsletter (SECURITY INVOKER - search_path secure)';

COMMENT ON FUNCTION unsubscribe_from_newsletter() IS
'Unsubscribe current user from newsletter (SECURITY INVOKER - search_path secure)';

COMMENT ON FUNCTION get_newsletter_subscribers() IS
'Admin-only function to get all newsletter subscribers (SECURITY INVOKER - search_path secure)';

-- ============================================
-- VERIFICATION QUERIES
-- ============================================

-- Check Newsletter functions have search_path set
-- Run this to verify:
/*
SELECT
  p.proname as function_name,
  CASE
    WHEN p.proconfig IS NULL THEN '❌ No search_path'
    WHEN 'search_path=public, pg_temp' = ANY(p.proconfig) THEN '✅ Secure'
    ELSE '⚠️ Other config: ' || array_to_string(p.proconfig, ', ')
  END as status,
  pg_get_functiondef(p.oid) as function_definition
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public'
  AND p.proname IN (
    'subscribe_to_newsletter',
    'unsubscribe_from_newsletter',
    'get_newsletter_subscribers'
  )
ORDER BY p.proname;
*/

-- Expected: All 3 functions should show ✅ Secure

-- To find all functions WITHOUT search_path in your database:
/*
SELECT
  n.nspname as schema_name,
  p.proname as function_name,
  pg_get_function_identity_arguments(p.oid) as arguments
FROM pg_proc p
JOIN pg_namespace n ON p.pronamespace = n.oid
WHERE n.nspname = 'public'
  AND p.proconfig IS NULL
ORDER BY p.proname;
*/
